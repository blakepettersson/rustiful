extern crate url;

use self::url::form_urlencoded;
use errors::QueryStringParseError;
use std::collections::HashMap;
use std::collections::hash_map::Entry::Occupied;
use std::collections::hash_map::Entry::Vacant;
use std::str::FromStr;
use try_from::TryFrom;

#[derive(Debug, PartialEq, Eq, Clone)]
/// A type-safe container for all incoming query parameters in a request.
///
/// # Example
///
/// ```
/// extern crate rustiful;
///
/// use std::collections::HashMap;
///
/// #[derive(Debug, PartialEq, Eq, Clone)]
/// // This enum will typically be generated by rustiful-derive
/// enum GeneratedSortParam {
///     foo(rustiful::SortOrder),
///     bar(rustiful::SortOrder)
/// }
///
/// // This enum will typically be generated by rustiful-derive
/// #[derive(Debug, PartialEq, Eq, Clone)]
/// enum GeneratedFieldSetParam {
///     foo,
///     bar,
/// }
///
/// let fields = vec![GeneratedFieldSetParam::foo, GeneratedFieldSetParam::bar];
/// let sort = vec![GeneratedSortParam::foo(rustiful::SortOrder::Asc)];
/// let query_params = HashMap::new();
///
/// let params = rustiful::JsonApiParams::new(fields.clone(), sort.clone(), query_params.clone());
///
/// assert_eq!(fields, params.fieldset.fields);
/// assert_eq!(sort, params.sort.fields);
/// assert_eq!(query_params, params.query_params);
/// ```
pub struct JsonApiParams<F, S> {
    /// A type-safe container for the "sort" query parameter in JSONAPI.
    ///
    /// The type parameter `<S>` will usually be an enum type that is generated using the `JsonApi`
    /// attribute in rustiful-derive.
    pub sort: Sort<S>,
    /// A type-safe container for the "fields" query parameter in JSONAPI.
    ///
    /// The type parameter `<F>` will usually be an enum type that is generated using the `JsonApi`
    /// attribute in rustiful-derive.
    pub fieldset: FieldSet<F>,
    /// A hashmap representing all other query parameters that are not `sort` or `fields[*]`.
    pub query_params: HashMap<String, Vec<String>>,
}

impl<F, S> JsonApiParams<F, S> {
    pub fn new(fieldset: Vec<F>,
               sort_params: Vec<S>,
               query_params: HashMap<String, Vec<String>>)
               -> JsonApiParams<F, S> {
        JsonApiParams {
            sort: Sort { fields: sort_params },
            fieldset: FieldSet { fields: fieldset },
            query_params: query_params,
        }
    }
}

/// Converts a query string to a type-safe representation.
///
/// This function converts a query string to `JsonApiParams<F, S>` for any type `F` that has a
/// `TryFrom<(&'b str, Vec<&'b str>)` implementation and for any type `S` that has a
/// `TryFrom<(&'b str, SortOrder)` implementation. All of these types and implementations will
/// typically be automatically generated when deriving `JsonApi` on your resource type.
///
/// # Errors
///
/// * If any field name in the `fields` query parameter doesn't match with any of the field
/// names in the type deriving this trait (or rather if the string doesn't match with a string
/// present in the `TryFrom` impl of the generated `field` enum.)
/// * If any field name in the `sort` query parameter doesn't match with any of the field
/// names in the type deriving this trait (or rather if the string doesn't match with a string
/// present in the `TryFrom` impl of the generated `sort` enum.)
///
/// # Example
///
/// Given a resource that has a `JsonApi` derive, such as the one below:
///
/// ```
/// # #[macro_use]
/// # extern crate serde_derive;
/// #
/// # #[macro_use]
/// # extern crate rustiful_derive;
/// #
/// #[derive(Debug, PartialEq, Eq, Clone, JsonApi, Default)]
/// struct MyResource {
///     id: String,
///     foo: bool,
///     bar: String
/// }
/// #
/// # fn main() {
/// # }
/// ```
///
/// Then you can call `from_str` with a query string to create a new instance of
/// `JsonApiParams<MyResource::FilterField, MyResource::SortField>`.
///
/// ```
/// # extern crate rustiful;
/// #
/// # #[macro_use]
/// # extern crate serde_derive;
/// #
/// # #[macro_use]
/// # extern crate rustiful_derive;
/// #
/// # use rustiful::TryFrom;
/// # use rustiful::JsonApiParams;
/// # use rustiful::JsonApiResource;
/// # use rustiful::SortOrder;
/// # use std::collections::HashMap;
/// # use std::str::FromStr;
/// #
/// # #[derive(Debug, PartialEq, Eq, Clone, JsonApi, Default)]
/// # struct MyResource {
/// #    id: String,
/// #    foo: bool,
/// #    bar: String
/// # }
/// #
/// # fn main() {
/// let query_string = "sort=-foo&fields[my-resources]=bar&other=test&other=abc";
/// let params = <MyResource as JsonApiResource>::Params::from_str(query_string);
/// # }
/// ```
impl <F, S> FromStr for JsonApiParams<F, S>
    where S: for<'b> TryFrom<(&'b str, SortOrder), Error = QueryStringParseError>,
          F: for<'b> TryFrom<(&'b str, Vec<&'b str>), Error = QueryStringParseError> {

    type Err = QueryStringParseError;

    fn from_str<'a>(query_string: &'a str) -> Result<Self, Self::Err> {
        let mut sort_params = Vec::new();
        let mut field_params = Vec::new();
        let mut query_params: HashMap<String, Vec<String>> = HashMap::new();

        let decoded = form_urlencoded::parse(query_string.as_bytes()).into_owned();

        for (key, value) in decoded {
            if &key == "sort" {
                if !sort_params.is_empty() {
                    return Err(QueryStringParseError::DuplicateSortKey(value));
                }

                let fields = value.split(',').filter(|&f| !f.is_empty());
                for mut field in fields {
                    let sort_order = SortOrder::from(field);
                    if sort_order == SortOrder::Desc {
                        field = field.trim_left_matches('-');
                    }

                    match S::try_from((field, sort_order)) {
                        Ok(result) => sort_params.push(result),
                        Err(err) => return Err(err),
                    }
                }
            } else if key.starts_with("fields") {
                let mut model = key.trim_left_matches("fields");

                if !model.starts_with('[') || !model.ends_with(']') {
                    return Err(QueryStringParseError::InvalidFieldsetKey(model.to_string()));
                }

                model = model.trim_left_matches('[').trim_right_matches(']');

                if model.is_empty() {
                    return Err(QueryStringParseError::InvalidFieldsetKey(key.to_string()));
                }

                // This can introduce duplicates, but we don't really care. If there are
                // duplicates it won't have any adverse effects - the field will still be
                // visible.
                let fields: Vec<_> = value.split(',').filter(|&f| !f.is_empty()).collect();

                if fields.is_empty() {
                    return Err(QueryStringParseError::EmptyFieldsetValue(model.to_string()));
                }

                match F::try_from((model, fields)) {
                    Ok(result) => field_params.push(result),
                    Err(err) => return Err(err),
                }
            } else {
                match query_params.entry(key) {
                    // Already a Vec here, push onto it
                    Occupied(entry) => {
                        entry.into_mut().push(value);
                    }
                    // No value, create a one-element Vec.
                    Vacant(entry) => {
                        entry.insert(vec![value]);
                    }
                };
            }
        }

        Ok(JsonApiParams::new(field_params, sort_params, query_params))
    }
}

impl<F, S> Default for JsonApiParams<F, S> {
    fn default() -> Self {
        let query_params: HashMap<String, Vec<String>> = Default::default();
        JsonApiParams::new(vec![], vec![], query_params)
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
/// A type-safe container for the "sort" query parameter in JSONAPI.
///
/// The type parameter `<S>` will usually be an enum type that is generated using the `JsonApi`
/// attribute in rustiful-derive.
pub struct Sort<S> {
    pub fields: Vec<S>,
}

#[derive(Debug, PartialEq, Eq, Clone)]
/// A type-safe container for the "fields" query parameter in JSONAPI.
///
/// The type parameter `<F>` will usually be an enum type that is generated using the `JsonApi`
/// attribute in rustiful-derive.
pub struct FieldSet<F> {
    pub fields: Vec<F>,
}

#[derive(Debug, PartialEq, Eq, Copy, Clone)]
/// This enum specifies how a parameter should be sorted.
pub enum SortOrder {
    /// The parameter should be sorted in an ascending order
    Asc,
    /// The parameter should be sorted in a descending order
    Desc,
}


/// Converts a string slice to a `SortOrder`.
///
/// If any parts of the field parameter are prefixed with a `-` in the incoming request,
/// then it should be sorted in a descending order, otherwise in an ascending order.
///
/// # Example
///
/// ```
/// # extern crate rustiful;
/// #
/// # use rustiful::SortOrder;
/// #
/// # fn main() {
/// let asc_param = "foo";
/// let desc_param = "-foo";
/// assert_eq!(SortOrder::Asc, SortOrder::from(asc_param));
/// assert_eq!(SortOrder::Desc, SortOrder::from(desc_param));
/// # }
/// ```
impl <'a> From<&'a str> for SortOrder {
    fn from(field: &'a str) -> Self {
        if field.starts_with('-') {
            SortOrder::Desc
        } else {
            SortOrder::Asc
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_order() {
        let asc_param = "foo";
        let desc_param = "-foo";
        assert_eq!(SortOrder::Asc, SortOrder::from(asc_param));
        assert_eq!(SortOrder::Desc, SortOrder::from(desc_param));
    }
}
