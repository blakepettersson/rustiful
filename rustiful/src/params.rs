extern crate url;
extern crate serde_qs as qs;

use std::fmt::Display;
use self::qs::Config;
use std::collections::HashMap;
use std::str::FromStr;
use serde::Deserialize;
use std::fmt::Debug;

#[serde(default)]
#[derive(Debug, PartialEq, Eq, Clone, Deserialize)]
/// A type-safe container for all incoming query parameters in a request.
///
/// # Example
///
/// ```
/// extern crate rustiful;
///
/// use std::collections::HashMap;
///
/// #[derive(Debug, PartialEq, Eq, Clone)]
/// // This enum will typically be generated by rustiful-derive
/// enum GeneratedSortParam {
///     foo(rustiful::SortOrder),
///     bar(rustiful::SortOrder)
/// }
///
/// // This enum will typically be generated by rustiful-derive
/// #[derive(Debug, PartialEq, Eq, Clone)]
/// enum GeneratedFieldSetParam {
///     foo,
///     bar,
/// }
///
/// let fields = vec![GeneratedFieldSetParam::foo, GeneratedFieldSetParam::bar];
/// let sort = vec![GeneratedSortParam::foo(rustiful::SortOrder::Asc)];
/// let query_params = HashMap::new();
///
/// let params = rustiful::JsonApiParams::new(fields.clone(), sort.clone(), query_params.clone());
///
/// assert_eq!(fields, params.fieldset.fields);
/// assert_eq!(sort, params.sort.fields);
/// assert_eq!(query_params, params.query_params);
/// ```
pub struct JsonApiParams<F: Default, S: FromStr> where <S as FromStr>::Err: Display {
    /// A type-safe container for the "sort" query parameter in JSONAPI.
    ///
    /// The type parameter `<S>` will usually be an enum type that is generated using the `JsonApi`
    /// attribute in rustiful-derive.
    #[serde(deserialize_with = "::json::comma_separated::deserialize")]
    pub sort: Vec<S>,
    /// A type-safe container for the "fields" query parameter in JSONAPI.
    ///
    /// The type parameter `<F>` will usually be an enum type that is generated using the `JsonApi`
    /// attribute in rustiful-derive.
    ///#[serde(rename = "fields")]
    pub fields: F
}

impl<F: Default, S: FromStr> JsonApiParams<F, S> where <S as FromStr>::Err: Display {
    pub fn new(
        fieldset: F,
        sort: Vec<S>
    ) -> JsonApiParams<F, S> {
        JsonApiParams {
            sort,
            fields: fieldset
        }
    }
}

/// Converts a query string to a type-safe representation.
///
/// This function converts a query string to `JsonApiParams<F, S>` for any type `F` that has a
/// `TryFrom<(&'b str, Vec<&'b str>)` implementation and for any type `S` that has a
/// `TryFrom<(&'b str, SortOrder)` implementation. All of these types and implementations will
/// typically be automatically generated when deriving `JsonApi` on your resource type.
///
/// # Errors
///
/// * If any field name in the `fields` query parameter doesn't match with any of the field
/// names in the type deriving this trait (or rather if the string doesn't match with a string
/// present in the `TryFrom` impl of the generated `field` enum.)
/// * If any field name in the `sort` query parameter doesn't match with any of the field
/// names in the type deriving this trait (or rather if the string doesn't match with a string
/// present in the `TryFrom` impl of the generated `sort` enum.)
///
/// # Example
///
/// Given a resource that has a `JsonApi` derive, such as the one below:
///
/// ```
/// # #[macro_use]
/// # extern crate serde_derive;
/// #
/// # #[macro_use]
/// # extern crate rustiful_derive;
/// #
/// #[derive(Debug, PartialEq, Eq, Clone, JsonApi, Default)]
/// struct MyResource {
///     id: String,
///     foo: bool,
///     bar: String
/// }
/// #
/// # fn main() {
/// # }
/// ```
///
/// Then you can call `from_str` with a query string to create a new instance of
/// `JsonApiParams<MyResource::FilterField, MyResource::SortField>`.
///
/// ```
/// # extern crate rustiful;
/// #
/// # #[macro_use]
/// # extern crate serde_derive;
/// #
/// # #[macro_use]
/// # extern crate rustiful_derive;
/// #
/// # use std::convert::TryFrom;
/// # use rustiful::JsonApiParams;
/// # use rustiful::JsonApiResource;
/// # use rustiful::SortOrder;
/// # use std::collections::HashMap;
/// # use std::str::FromStr;
/// #
/// # #[derive(Debug, PartialEq, Eq, Clone, JsonApi, Default)]
/// # struct MyResource {
/// #    id: String,
/// #    foo: bool,
/// #    bar: String
/// # }
/// #
/// # fn main() {
/// let query_string = "sort=-foo&fields[my-resources]=bar&other=test&other=abc";
/// let params = <MyResource as JsonApiResource>::Params::from_str(query_string);
/// # }
/// ```
impl<F, S> FromStr for JsonApiParams<F, S>
where
    S: FromStr + Debug,
    F: Default + Debug,
    S: for<'b> Deserialize<'b>,
    F: for<'b> Deserialize<'b>,
    <S as FromStr>::Err: Display
{
    type Err = qs::Error;

    fn from_str<'a>(query_string: &'a str) -> Result<Self, Self::Err> {
        let config = Config::new(10, false);
        let result = config.deserialize_str(query_string);
        println!("{:?}", result);
        result
    }
}

impl<F: Default, S: FromStr> Default for JsonApiParams<F, S> where <S as FromStr>::Err: Display {
    fn default() -> Self {
        JsonApiParams::new(F::default(), Vec::new())
    }
}

#[derive(Debug, PartialEq, Eq, Copy, Clone, Deserialize)]
/// This enum specifies how a parameter should be sorted.
pub enum SortOrder {
    /// The parameter should be sorted in an ascending order
    Asc,
    /// The parameter should be sorted in a descending order
    Desc
}

/// Converts a string slice to a `SortOrder`.
///
/// If any parts of the field parameter are prefixed with a `-` in the incoming request,
/// then it should be sorted in a descending order, otherwise in an ascending order.
///
/// # Example
///
/// ```
/// # extern crate rustiful;
/// #
/// # use rustiful::SortOrder;
/// #
/// # fn main() {
/// let asc_param = "foo";
/// let desc_param = "-foo";
/// assert_eq!(SortOrder::Asc, SortOrder::from(asc_param));
/// assert_eq!(SortOrder::Desc, SortOrder::from(desc_param));
/// # }
/// ```
impl<'a> From<&'a str> for SortOrder {
    fn from(field: &'a str) -> Self {
        if field.starts_with('-') {
            SortOrder::Desc
        } else {
            SortOrder::Asc
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_order() {
        let asc_param = "foo";
        let desc_param = "-foo";
        assert_eq!(SortOrder::Asc, SortOrder::from(asc_param));
        assert_eq!(SortOrder::Desc, SortOrder::from(desc_param));
    }
}
